#ifndef _COM_										//Защита от повторного включения файла
#define _COM_

#include <avr/iom128.h>								//Стандартная библиотека ввода/вывода
#include <avr/interrupt.h>							//Библиотека обработки прерываний

#ifndef F_CPU
# warning "F_CPU not defined. Frequency by default 14.7456 MHz"
#define F_CPU 14745600UL							/*Стандартная константа задающая частоту микроконтроллера (необходима для корректной работы функций задержек)*/
#endif
#define _TIMER_DIV 8								/*Коэффициент делителя частоты таймеров 1 и 3*/

#include <util/delay.h>								//Стандартная библиотека временных задержек

#define ENABLE	1									/*Константа "Контрольная сумма протокола DCON включена"*/
#define DISABLE	0									/*Константа "Контрольная сумма протокола DCON отключена"*/
#define DCON	0									/*Константа "Протокол DCON"*/
#define MODBUS	1									/*Константа "Протокол Modbus RTU"*/
#define COM_PORT1	0								/*Константа "Порт COM1"*/
#define COM_PORT2	1								/*Константа "Порт COM2"*/

#ifndef COM_RX_BUFFER_SIZE							
# warning "COM_RX_BUFFER_SIZE not defined. Value will be set by default 64 bytes"
#define COM_RX_BUFFER_SIZE 64						/*Длина приемного буфера*/
#endif
#ifndef COM_TX_BUFFER_SIZE							
# warning "COM_TX_BUFFER_SIZE not defined. Value will be set by default 64 bytes"
#define COM_TX_BUFFER_SIZE 64						/*Длина передающего буфера*/
#endif

char _CHK_mode[2]={0,0};							//Признак включения/выключения контрольной суммы в протоколе DCON
char _Protocol[2]={0,0};							//Протокол работы(0-DCON/1-Modbus RTU)
char _Frame_pause[2];								//Флаг превышения интервала 1.5 символа в Modbus RTU (1-интервал превышен/0-превышения не было)


static char _UART_RX_Buf[2][COM_RX_BUFFER_SIZE];	//Приемный буфер UART
static char _UART_RX_dup[2][COM_RX_BUFFER_SIZE];	//Копия приемного буфера UART
static int _UART_RX_point[2];						//Текущая позиция в приемном буфере UART
static char _UART_RX_length[2];						//Длина принятой посылки по UART
static char _UART_RX_end[2];						//Признак окончания принятой посылки по UART

static char _UART_TX_Buf[2][COM_TX_BUFFER_SIZE];	//Передающий буфер UART
static int _UART_TX_point[2];						//Текущая позиция в передающем буфере UART
static char _UART_TX_length[2];						//Длинна отправляемой посылки по UART
static char _UART_TX_end[2];						//Признак окончания передачи по UART

#ifdef COM1_MODBUS
//------------------------------------------------------------------------------------------
//======================== Прерывание по совпадению А таймера 1 ============================
//------------------------------------------------------------------------------------------
SIGNAL(TIMER1_COMPA_vect)
{
	int temp;																//Вспомогательная переменная
	
	_Frame_pause[0]=0;														//Обнуление флага превышения интервала 1.5 символа
	
	for (temp=0; temp<_UART_RX_point[0]; temp++) _UART_RX_dup[0][temp]=_UART_RX_Buf[0][temp];//Копирование приемного буфера
	_UART_RX_length[0]=_UART_RX_point[0];								    //Вычисление длины принятой посылки
	_UART_RX_point[0]=0;										            //Указатель приемного буфера на начало
	TCCR1B=0x00;															//Остановка таймера
	_UART_RX_end[0]=1;														//Установить признак окончания приема
}

//------------------------------------------------------------------------------------------
//======================== Прерывание по совпадению B таймера 1 ============================
//------------------------------------------------------------------------------------------
SIGNAL(TIMER1_COMPB_vect)
{
	_Frame_pause[0]=1;														//Установить флаг превышения интервала 1.5 символа
}
#endif

//=============================== Прерывание по приему UART0 ===============================
SIGNAL(USART0_RX_vect)
{
	if (_Protocol[0]==MODBUS)
	{
#ifdef COM1_MODBUS
		
//---------------------------------- Если протокол Modbus ----------------------------------
		if (_Frame_pause[0]==0)                                             //Если не было превышение интервала 1.5 символа                       
		{
			_UART_RX_Buf[0][_UART_RX_point[0]]=UDR0;						//Чтение регистра приемника
			TIFR|=(1<<OCF1A)|(1<<OCF1B);                                    //Обнуление флага прерывания по таймеру (необходимо если прерывание возникло в момент выполнения данного обработчика)
			TCNT1=0;                                                        //Обнуление счетного регистра таймера
			TCCR1B=(1<<WGM12)|(1<<CS11);									//Установка режима работы таймера "Сброс при совпадении" и коэффициента деления частоты 8
			_UART_RX_point[0]++;                                            //Увеличение счетчика принятых байт
			if (_UART_RX_point[0]>=COM_RX_BUFFER_SIZE-1) _UART_RX_point[0]=0;//Защита от длинной бессмысленной команды
		}
#endif
	}
	else
//----------------------------------- Если протокол DCON -----------------------------------
	{
		char temp;															//Вспомогательная переменная
		
		_UART_RX_Buf[0][_UART_RX_point[0]]=UDR0;							//Чтение регистра приемника

		switch (_UART_RX_Buf[0][_UART_RX_point[0]])                         //Если принят символ идентификации, считать что это начало посылки
		{
			case '$':
			case '%':
			case '~':
			case '@':
			case '#':
			case '^':
			case '!':
			case '?':
			case '>':
			temp=_UART_RX_Buf[0][_UART_RX_point[0]];						//Сохранить идентификационный символ во временной переменной
			_UART_RX_point[0]=0;											//Установить текущую позицию в приемном буфере в ноль
			_UART_RX_Buf[0][0]=temp;										//Перезаписать в нулевую позицию буфера принятый элемент
		}
	
		if (_UART_RX_Buf[0][_UART_RX_point[0]]==0x0D)						//Если принят байт конца посылки
		{
			
			_UART_RX_length[0]=_UART_RX_point[0]+1;							//Сохранение длины посылки

			//Копирование приемного буфера
			for (_UART_RX_point[0]=0; _UART_RX_point[0]<=_UART_RX_length[0]; _UART_RX_point[0]++) _UART_RX_dup[0][_UART_RX_point[0]]=_UART_RX_Buf[0][_UART_RX_point[0]];
			_UART_RX_point[0]=0;											//Очистка счетчика элементов буфера
			_UART_RX_end[0]=1;												//Установить признак окончания приема
		}
		else
		{
			_UART_RX_point[0]++;											//Увеличение счетчика элементов буфера
			if (_UART_RX_point[0]>=COM_RX_BUFFER_SIZE-1) _UART_RX_point[0]=0;//Защита от длинной бессмысленной команды
		}
	}
}

//============================= Прерывание по передачи UART0 ===============================
SIGNAL(USART0_TX_vect)
{
	if (_UART_TX_point[0]==_UART_TX_length[0])								//Если отправлена вся посылка
	{
		_UART_TX_point[0]=0;												//Очистка счетчика элемнтов буфера
		PORTG&=~(1<<PG0);													//Переключить RS485 на прием
		_UART_TX_end[0]=1;													//Установить флаг завершения передачи
	}
	else
	{
		UDR0=_UART_TX_Buf[0][_UART_TX_point[0]];							//Отправка байта по UART0
		_UART_TX_point[0]++;												//Увеличение счетчика элементов буфера
	}
}

#ifdef COM2_MODBUS
//------------------------------------------------------------------------------------------
//======================== Прерывание по совпадению А таймера 3 ============================
//------------------------------------------------------------------------------------------
SIGNAL(TIMER3_COMPA_vect)
{
	int temp;																//Вспомогательная переменная
	
	_Frame_pause[1]=0;														//Обнуление флага превышения интервала 1.5 символа
	
	for (temp=0; temp<_UART_RX_point[1]; temp++) _UART_RX_dup[1][temp]=_UART_RX_Buf[1][temp];//Копирование приемного буфера
	_UART_RX_length[1]=_UART_RX_point[1];								    //Вычисление длины принятой посылки
	_UART_RX_point[1]=0;										            //Указатель приемного буфера на начало
	TCCR3B=0x00;															//Остановка таймера
	_UART_RX_end[1]=1;														//Установить признак окончания приема
}

//------------------------------------------------------------------------------------------
//======================== Прерывание по совпадению B таймера 3 ============================
//------------------------------------------------------------------------------------------
SIGNAL(TIMER3_COMPB_vect)
{
	_Frame_pause[1]=1;														//Установить флаг превышения интервала 1.5 символа
}
#endif

//=============================== Прерывание по приему UART1 ===============================
SIGNAL(USART1_RX_vect)
{
	if (_Protocol[1]==MODBUS)
	{
#ifdef COM2_MODBUS
//---------------------------------- Если протокол Modbus ----------------------------------
		if (_Frame_pause[1]==0)                                             //Если не было превышение интервала 1.5 символа
		{
			_UART_RX_Buf[1][_UART_RX_point[1]]=UDR1;						//Чтение регистра приемника
			ETIFR|=(1<<OCF3A)|(1<<OCF3B);                                   //Обнуление флага прерывания по таймеру (необходжимо если прерывание возникло в момент выполнения данного обработчика)
			TCNT3=0;                                                        //Обнуление счетного регистра таймера
			TCCR3B=(1<<WGM32)|(1<<CS31);									//Установка режима работы таймера "Сброс при совпадении" и коэффициента деления частоты 8
			_UART_RX_point[1]++;                                            //Увеличение счетчика принятых байт
			if (_UART_RX_point[1]>=COM_RX_BUFFER_SIZE-1) _UART_RX_point[1]=0;//Защита от длинной бессмысленной команды
		}
#endif
	}
	else
//----------------------------------- Если протокол DCON -----------------------------------
	{
		char temp;															//Вспомогательная переменная

		_UART_RX_Buf[1][_UART_RX_point[1]]=UDR1;							//Чтение регистра приемника

		switch (_UART_RX_Buf[1][_UART_RX_point[1]])                         //Если принят символ идентификации, считать что это начало посылки
		{
			case '$':
			case '%':
			case '~':
			case '@':
			case '#':
			case '^':
			case '!':
			case '?':
			case '>':
			temp=_UART_RX_Buf[1][_UART_RX_point[1]];						//Сохранить идентификационный символ во временной переменной
			_UART_RX_point[1]=0;											//Установить текущую позицию в приемном буфере в ноль
			_UART_RX_Buf[1][0]=temp;										//Перезаписать в нулевую позицию буфера принятый элемент
		}
		
		if (_UART_RX_Buf[1][_UART_RX_point[1]]==0x0D) 						//Если принят байт конца посылки
		{
			_UART_RX_length[1]=_UART_RX_point[1]+1;							//Сохранение длины посылки

			for (_UART_RX_point[1]=0; _UART_RX_point[1]<=_UART_RX_length[1]; _UART_RX_point[1]++) _UART_RX_dup[1][_UART_RX_point[1]]=_UART_RX_Buf[1][_UART_RX_point[1]];//Копирование приемного буфера
			_UART_RX_point[1]=0;											//Очистка счетчика элементов буфера
			_UART_RX_end[1]=1;												//Установить признак окончания приема
		}
		else
		{
			_UART_RX_point[1]++;											//Увеличение счетчика элементов буфера
			if (_UART_RX_point[1]>=COM_RX_BUFFER_SIZE-1) _UART_RX_point[1]=0;//Защита от длинной бессмысленной команды
		}
	}
}

//============================= Прерывание по передачи UART1 ===============================
SIGNAL(USART1_TX_vect)
{
	if (_UART_TX_point[1]==_UART_TX_length[1])								//Если отправлена вся посылка
	{
		_UART_TX_point[1]=0;												//Очистка счетчика элемнтов буфера
		PORTG&=~(1<<PG1);													//Переключить RS485 на прием
		_UART_TX_end[1]=1;													//Установить флаг завершения передачи
	}
	else
	{
		UDR1=_UART_TX_Buf[1][_UART_TX_point[1]];							//Отправка байта по UART0
		_UART_TX_point[1]++;												//Увеличение счетчика элементов буфера
	}
}

//=========================== Функция инициализации COM порта ==============================
//Функция принимает в качестве параметров:
//port - Номер COM порта
//COM_speed - Скорости связи по UART
//Protocol - Протокол связи (0-DCON/1-Modbus RTU)
//Функция возвращает:
//0x00-если все параметры заданы корректно, в противном случае 0xFF

char COM_Init(int port, long COM_speed, char Protocol)
{
	if (port>1) return 0xFF;												//Если не верно задан номер COM порта
	if ((COM_speed<=0) || (COM_speed>1000000)) return 0xFF;					//Если не верно задана скорость
	if (Protocol>1) return 0xFF;											//Если не верно задан признак включения/выключения контрольной суммы
	
	_Protocol[port]=Protocol;												//Выбор протокола
		
	float temp;
	
	temp=(float)F_CPU/COM_speed/16-0.5;										//Расчет значения регистра скорости UART
	if (temp>=0.5)															//Если скорость допустимая для данного кварца
	{
		if (port==0)
		{
			UBRR0H=(unsigned long)temp>>8;
			UBRR0L=(unsigned long)temp & 0x000000FF;
		}
		else 
		{
			UBRR1H=(unsigned long)temp>>8;
			UBRR1L=(unsigned long)temp & 0x000000FF;
		}		
	}
	else return 0xFF;														//иначе, выход с ошибкой

	if (COM_speed>=19200) COM_speed=19200;									//Если значение скорости 19200 бит/сек или больше, длительность тишины равна 1.75 мс.
	if (port==0)
	{	
		UCSR0B=(1<<RXCIE0)|(1<<RXEN0)|(1<<TXEN0)|(1<<TXCIE0);				//Настройка приемо-передатчика
		if (Protocol==MODBUS) UCSR0C=(1<<UCSZ00)|(1<<UCSZ01)|(1<<USBS0);	//Формат обмена (8N2) для протокола Modbus RTU
		else UCSR0C=(1<<UCSZ00)|(1<<UCSZ01);								//Формат обмена (8N1)
		DDRG|=(1<<PG0);														//Настройка линии управления драйвером RS485
		PORTG&=~(1<<PG0);													//Переключить UART0 на прием

		_UART_RX_point[port]=0;												//Указатель на начало буфера
		_UART_RX_end[port]=0;												//Сбросить признак окончания приема
		_UART_TX_end[port]=1;												//Установить флаг завершения предачи
		
#ifdef COM1_MODBUS
		TCCR1A=0;
		OCR1A=35*(float)F_CPU/COM_speed/_TIMER_DIV+0.5;						//Расчет длительности 3.5 символов
		OCR1B=15*(float)F_CPU/COM_speed/_TIMER_DIV+0.5;						//Расчет длительности 1.5 символов
		TIMSK|=(1<<OCIE1A)|(1<<OCIE1B);										//Разрешение прерывание по совпадению А и B таймера 1		
		sei();																//Разрешить все прерывания		
#endif
	}
	else
	{
		UCSR1B=(1<<RXCIE1)|(1<<RXEN1)|(1<<TXEN1)|(1<<TXCIE1);				//Настройка приемо-передатчика
		if (Protocol==MODBUS) UCSR1C=(1<<UCSZ10)|(1<<UCSZ11)|(1<<USBS1);	//Формат обмена (8N2) для протокола Modbus RTU
		else UCSR1C=(1<<UCSZ10)|(1<<UCSZ11);									//Формат обмена (8N1)
		DDRG|=(1<<PG1);														//Настройка линии управления драйвером RS485
		PORTG&=~(1<<PG1);													//Переключить UART1 на прием

		_UART_RX_point[port]=0;												//Указатель на начало буфера
		_UART_RX_end[port]=0;												//Сбросить признак окончания приема
		_UART_TX_end[port]=1;												//Установить флаг завершения предачи
		
#ifdef COM2_MODBUS
		TCCR3A=0;
		OCR3A=35*(float)F_CPU/COM_speed/_TIMER_DIV+0.5;						//Расчет длительности 3.5 символов
		OCR3B=15*(float)F_CPU/COM_speed/_TIMER_DIV+0.5;						//Расчет длительности 1.5 символов
		ETIMSK|=(1<<OCIE3A)|(1<<OCIE3B);									//Разрешение прерывание по совпадению А и B таймера 3
		sei();																//Разрешить все прерывания
#endif
	}
	return 0;
}

//============ Функция включения/выключения контрольной суммы протокола DCON ===============
//Функция принимает в качестве параметров:
//port - Номер COM порта
//CHK - Признак включения/выключения контрольной суммы протокола DCON
//Функция возвращает:
//0x00-если выбран протокол DCON и признак включения контрольнрой суммы задан корретно, в противном случае 0xFF

char CHK_Control(int port, char CHK)
{
	if (port>1) return 0xFF;												//Если не верно задан номер COM порта
	if ((CHK>1) || (_Protocol[port]==1)) return 0xFF;						//Если не верно задан признак включения/выключения контрольной суммы или не выбран протокол DCON
	_CHK_mode[port]=CHK;													//Выбор режима контрольной суммы протокола DCON
	return 0;
}

//==================== Функция запуска передачи информации по UART =========================
//Функция принимает в качестве параметров:
//port - Номер COM порта
//Len - Длина передаваемых данных

void _UART_Go(char port, int Len)
{
	if (port==0)															//Если указан COM1
	{
		_UART_TX_end[0]=0;													//Сброс флага окончания передачи (отправка новой посылки)
		PORTG|=(1<<PG0);													//Переключить RS485 на передачу
		_delay_us(5);														//Задержка для переключения микросхемы драйвера
		_UART_TX_length[0]=Len;												//Длина передаваемых данных
		_UART_TX_point[0]=1;												//Позиция в передающем буфере
		UDR0=_UART_TX_Buf[0][0];											//Отправка по UART0 первого символа (остальные будут отправляться в прерывании)
	}
	else																	//Если указан COM2
	{
		_UART_TX_end[1]=0;													//Сброс флага окончания передачи (отправка новой посылки)

		PORTG|=(1<<PG1);													//Переключить RS485 на передачу
		_delay_us(5);														//Задержка для переключения микросхемы драйвера

		_UART_TX_length[1]=Len;												//Длина передаваемых данных
		_UART_TX_point[1]=1;												//Позиция в передающем буфере
		UDR1=_UART_TX_Buf[1][0];											//Отправка по UART1 первого символа (остальные будут отправляться в прерывании)		
	}
}

//======================= Функция записи данных по протоколу DCON ==========================
//Функция принимает:
//port - Номер COM порта
//*buf - Указатель на строку передаваемых данных
//Функция возвращает:
//0x00-если номер COM порта задан не верно, в противном случае 0xFF

char Write_DCON(int port, char *buf)
{
	if (port>1) return 0xFF;												//Если не верно задан номер COM порта
	char CHK_sum=0;															//Переменная для расчета контрольной суммы
	char temp;																//Вспомогательная переменная
	int Lengtch;															//Длина команды
	
	while (_UART_TX_end[port]==0) _delay_us(5);								//Ожидание окончания предыдущей передачи
	
	Lengtch=0;																//Обнуление счетчика символов в строке команды
	while (Lengtch<COM_TX_BUFFER_SIZE)										//Цикл, пока не встретися конец строки, символ возврата каретки или не заполнится буфер
	{
		_UART_TX_Buf[port][Lengtch]=*buf;
		if ((_UART_TX_Buf[port][Lengtch]==0) || (_UART_TX_Buf[port][Lengtch]==0x0D)) break;//Если достигнут конец строки или встретился символ возврат каретки
		CHK_sum+=_UART_TX_Buf[port][Lengtch];
		Lengtch++;															//Увеличить счетчик длинны строки команды
		buf++;																//Переход на следующий символ строки команды
	}
	
	if (_CHK_mode[port]==ENABLE)											//Если включена контрольная сумма и текущий протокол DCON
	{
		temp=CHK_sum>>4;													//Старший символ контрольной суммы
		if (temp<=9) _UART_TX_Buf[port][Lengtch]=temp+0x30;					//Если символ цифра (0-9)
		else _UART_TX_Buf[port][Lengtch]=temp+0x37;							//Если символ буква (A-F)
		Lengtch++;
		
		temp=CHK_sum & 0x0F;												//Младший символ контрольной суммы
		if (temp<=9) _UART_TX_Buf[port][Lengtch]=temp+0x30;					//Если символ цифра (0-9)
		else _UART_TX_Buf[port][Lengtch]=temp+0x37;							//Если символ буква (A-F)
		Lengtch++;
	}

	_UART_TX_Buf[port][Lengtch++]=0x0D;										//Замена символа конца строки на возврат каретки
	
	_UART_Go(port,Lengtch);													//Запуск передачи данных по UART
	return 0;
}

//======================= Функция чтения данных по протоколу DCON ==========================
//Функция производит чтение содержимого приемного буфера UART
//Функция принимает:
//port - Номер COM порта
//*buf-указатель на массив в который будут помещены считанные данные
//Функция возвращает:
//	0x00-если приемный буфер UART пуст;
//	0x01-данные из приемного буфера перемещены в глобальный массив для чтения;
//	0x80-Не соответствие протоколов (Выбран протокол Modbus);
//	0xFF-не совпадение контрольной суммы принятых данных.
//Функция заносит считанные данные в массив, адрес которого указан в качестве входного параметра.
//Нулевой элемент выходного массива содержит количество прочитаных байт.

char Read_DCON(int port, char *buf)
{
	int temp;																//Вспомогательная переменная
	char CHK_sum=0;															//Переменная для расчета контрольной суммы
	
	if (_UART_RX_end[port]==0) return 0;									//Выход если признак окончания приема не установлен
	if (_Protocol[port]!=DCON) return 0x80;									//Если текущий протокол Modbus
	_UART_RX_end[port]=0;													//Сброс флага окончания приема
	
	if (_CHK_mode[port]==ENABLE)											//Если включена контрольная сумма и текущий протокол DCON
	{
		for (temp=0;temp<_UART_RX_length[port]-3;temp++) CHK_sum+=_UART_RX_dup[port][temp];//Обычное сумирование всех элементов буфера, за исключением CR и самой контрольной суммы
		temp=CHK_sum>>4;													//Старший символ контрольной суммы
		if (temp<=9) temp+=0x30;											//Если символ цифра (0-9)
		else temp+=0x37;													//Если символ буква (A-F)
		if (temp!=_UART_RX_dup[port][_UART_RX_length[port]-3]) return 0xFF;	//Выход если не совпал первый символ контрольной суммы
		
		temp=CHK_sum & 0x0F;												//Младший символ контрольной суммы
		if (temp<=9) temp+=0x30;											//Если символ цифра (0-9)
		else temp+=0x37;													//Если символ буква (A-F)
		if (temp!=_UART_RX_dup[port][_UART_RX_length[port]-2]) return 0xFF;	//Выход если не совпал второй символ контрольной суммы
	}
	
	*buf=_UART_RX_length[port];												//Сохранение длинны принятых данных
	for (temp=0; temp<_UART_RX_length[port]; temp++)						//Перекопирование буфера
	{
		buf++;
		*buf=_UART_RX_dup[port][temp];
	}
	
	return 1;
}

//================= Функция расчета контрольной суммы в протоколе Modbus RTU ===============
//Функция принимает:
//*buf-указатель на массив в котором содержатся данные для расчета контрольной суммы
//Len-количество байт участвующих в расчете контрольной суммы
int _CRC_calc(char *buf, char Len)
{
	unsigned int CRC;														//Переменная для расчета контрольной суммы
	char temp,temp2;														//Вспомогательные переменные
	
	CRC=0xFFFF;																//Начальное значение CRC (по алгоритму расчета CRC)
	for (temp=0; temp<Len; temp++)											//Цикл для всех байт участвующих в расчете
	{
		CRC=CRC^*buf;														//"Исключающее или" (по алгоритму расчета CRC)
		buf++;																//Указатель на следующий байт
		for (temp2=0; temp2<8; temp2++)										//Цикл для каждого бита в байте
		if ((CRC & 0x0001)==0) CRC=CRC>>1;									//Если младший бит в единице, просто сдвиг (по алгоритму расчета CRC)
		else
		{
			CRC=CRC>>1;														//Сдвиг	и "Исключающее или" (по алгоритму расчета CRC)
			CRC=CRC^0xA001;													//Полином для "Исключающего или" 1010 0000 0000 0001
		}
	}
	
	return CRC;																//Возврат расчитанной контрольной суммы
}

//================ Функция чтения принятой посылки в протоколе Modbus RTU ==================
//Функция принимает:
//port - Номер COM порта
//*buf-массив для принятых данных
//Функция возвращает:
//	0x00-если приемный буфер UART пуст;
//	0x01-данные из приемного буфера UART перемещены в буфер для чтения;
//	0x80-Не соответствие протоколов (Выбран протокол DCON);
//	0xFF-не совпадение контрольной суммы принятых данных.
//Функция заносит считанные данные в массив, адрес которого указан в качестве входного параметра.
//Два байта контрольной суммы включены в данный массив.
//Нулевой элемент выходного массива содержит количество прочитаных байт, считая байты контрольной суммы.

char Read_Modbus(int port, char *buf)
{
	unsigned int CRC;														//Переменная для контрольной суммы
	int temp;
	
	if (_UART_RX_end[port]==0) return 0;									//Выход если признак окончания приема не установлен
	
	if (_Protocol[port]!=MODBUS) return 0x80;								//Если текущий протокол DCON	
	_UART_RX_end[port]=0;													//Сброс флага окончания приема
	
	CRC=_CRC_calc(_UART_RX_Buf[port],_UART_RX_length[port]-2);				//Расчет CRC

	//Проверка контрольной суммы
	if (((CRC>>8)!=_UART_RX_Buf[port][_UART_RX_length[port]-1]) || ((CRC & 0xFF)!=_UART_RX_Buf[port][_UART_RX_length[port]-2])) return 0xFF;

	*buf=_UART_RX_length[port];												//Записать в буфер длину принятой посылки
	for (temp=0; temp<_UART_RX_length[port]; temp++)						//Перекопировать буфер
	{
		buf++;
		*buf=_UART_RX_Buf[port][temp];
	}
	
	
	return 1;
}

//=============== Функция отправки ответа на команду в протоколе Modbus RTU ================
//Функция принимает:
//Addres-Адрес устройства
//Func-Код функции
//SubFunc-Код подфункции (адрес регистра)
//Data-Передаваемые данные
//Amount-Количество передаваемых элементов (регистров или ячеек)
//Функция возвращает:
//	0x00-успешное завершение работы
//	0xFE-не поддерживаемый номер функции
//	0xFF-не корректный номер COM порта

char Write_Response_Modbus(int port, char Addres, char Func, unsigned int SubFunc, char *Data, unsigned int Amount)
{
	unsigned int CRC;																			//Переменная для контрольной суммы
	int Lengtch;																				//Длинна команды
	char temp;																					//Вспомогательная переменная
	char _Error=0;																				//Флаг ошибки превышения длинны буфера
	
	if (port>1) return 0xFF;																	//Выход если номер COM порта указан не верно
	while (_UART_TX_end==0) _delay_us(5);														//Ожидание окончания предыдущей передачи
	
	Lengtch=0;
	_UART_TX_Buf[port][Lengtch++]=Addres;														//Адреса устройства
	_UART_TX_Buf[port][Lengtch++]=Func;															//Код функции
	
	if ((Func & 0x80)==0)																		//Если код функции не содержит ошибки
	{
		switch(Func)
		{
			case 0x01:
			case 0x02:
			Amount=((Amount-1)>>3)+1;															//Количество байт в посылке
			if (Amount>(COM_TX_BUFFER_SIZE-5)/2) {_Error=1; break;}
			_UART_TX_Buf[port][Lengtch++]=Amount;
			for (temp=0; temp<Amount; temp++)
			{
				_UART_TX_Buf[port][Lengtch++]=*Data;											//Перенести байт данных
				Data++;																			//Переход на следующий байт
			}
			break;

			case 0x03:
			case 0x04:
			if (Amount>(COM_TX_BUFFER_SIZE-5)/2) {_Error=1; break;}
			Amount<<=1;																			//Количество байт в посылке
			_UART_TX_Buf[port][Lengtch++]=Amount;
			for (temp=0; temp<Amount; temp++)
			{
				_UART_TX_Buf[port][Lengtch++]=*Data;											//Перенести байт данных
				Data++;																			//Переход на следующий байт
			}
			break;
			
			case 0x05:
			case 0x06:
			_UART_TX_Buf[port][Lengtch++]=SubFunc>>8;											//Старший байт кода подфункции
			_UART_TX_Buf[port][Lengtch++]=SubFunc & 0xFF;										//Младший байт кода подфункции
			
			_UART_TX_Buf[port][Lengtch++]=*Data;												//Старший байт значения регистра
			Data++;
			_UART_TX_Buf[port][Lengtch++]=*Data;												//Младший байт значения регистра
			break;
			
			case 0x0F:
			case 0x10:
			_UART_TX_Buf[port][Lengtch++]=SubFunc>>8;											//Старший байт кода подфункции
			_UART_TX_Buf[port][Lengtch++]=SubFunc & 0xFF;										//Младший байт кода подфункции
			
			_UART_TX_Buf[port][Lengtch++]=Amount>>8;											//Старший байт счетчика ячеек
			_UART_TX_Buf[port][Lengtch++]=Amount &0xFF;											//Младший байт счетчика регистра
			break;
			
			default: return 0xFE;																//Досрочный выход, если данная функция не поддерживается
		}
	}
	else _UART_TX_Buf[port][Lengtch++]=*Data;													//Если код функции содержит ошибку, добавить код ошибки
	
	if (_Error==0)
	{
		CRC=_CRC_calc(_UART_TX_Buf[port],Lengtch);												//Расчет контрольной суммы
		
		_UART_TX_Buf[port][Lengtch++]=CRC & 0xFF;												//Старший байт контрольной суммы
		_UART_TX_Buf[port][Lengtch++]=CRC>>8;													//Младший байт контрольной суммы
		
		_UART_Go(port,Lengtch);																	//Запуск передачи данных по UART
		return 0;																				//Успешное завершение функции
	}
	else return 1;
}

//==================== Функция отправки команды в протоколе Modbus RTU =====================
//Функция принимает:
//port-Номер COM порта
//Addres-Адрес устройства
//Func-Код функции
//SubFunc-Код подфункции (адрес регистра)
//*Data-Передаваемые данные
//Amount-Количество передаваемых элементов (регистров или ячеек)

void Write_Request_Modbus(int port, char Addres, char Func, unsigned int SubFunc, char *Data, unsigned int Amount)
{
	unsigned int CRC;														//Переменная для контрольной суммы
	int Lengtch;															//Длинна команды
	char temp;																//Вспомогательная переменная
	
	while (_UART_TX_end[port]==0) _delay_us(5);								//Ожидание окончания предыдущей передачи
	if (((Func<0x01) || (Func>0x06)) && (Func!=0x0F) && (Func!=0x10)) return; //Выход, если код функции не подходящий
	
	Lengtch=0;
	_UART_TX_Buf[port][Lengtch++]=Addres;									//Адреса устройства
	_UART_TX_Buf[port][Lengtch++]=Func;										//Код функции
	_UART_TX_Buf[port][Lengtch++]=SubFunc>>8;								//Старший байт кода подфункции
	_UART_TX_Buf[port][Lengtch++]=SubFunc & 0xFF;							//Младший байт кода подфункции

	if ((Func==0x0F) || (Func==0x10))										//Для функций 0x0F и 0x10.
	{
		_UART_TX_Buf[port][Lengtch++]=Amount>>8;							//Количество элементов в посылке
		_UART_TX_Buf[port][Lengtch++]=Amount & 0xFF;						//Количество элементов в посылке
		
		if (Func==0x10) Amount<<=1;											//Количество байт в посылке
		else 
			if (Func==0x0F) Amount=((Amount-1)>>3)+1;
			else return;
	
		_UART_TX_Buf[port][Lengtch++]=Amount;								//Занести в буфер количество записываемых регистров
		
		for (temp=0; temp<Amount; temp++) 
		{
			_UART_TX_Buf[port][Lengtch++]=*Data;							//Перенести байт данных
			Data++;															//Переход на следующий байт
		}
	}
	else
	{
		_UART_TX_Buf[port][Lengtch++]=*Data;								//Старший байт значения регистра
		Data++;
		_UART_TX_Buf[port][Lengtch++]=*Data;								//Младший байт значения регистра
	}
	
	CRC=_CRC_calc(_UART_TX_Buf[port],Lengtch);								//Расчет контрольной суммы
	
	_UART_TX_Buf[port][Lengtch++]=CRC & 0xFF;								//Старший байт контрольной суммы
	_UART_TX_Buf[port][Lengtch++]=CRC>>8;									//Младший байт контрольной суммы
	
	_UART_Go(port, Lengtch);												//Запуск передачи данных по UART
}
#endif