#ifndef _COM_																					//Защита от повторного включения файла
#define _COM_

#include <avr/iom128.h>																			//Стандартная библиотека ввода/вывода
#include <avr/interrupt.h>																		//Библиотека обработки прерываний

#ifndef F_CPU
# warning "F_CPU not defined. Frequency by default 14.7456 MHz"
#define F_CPU 14745600UL																		/*Стандартная константа задающая частоту микроконтроллера (необходима для корректной работы функций задержек)*/
#endif
#define _TIMER_DIV 8																			/*Коэффициент делителя частоты таймеров 1 и 3*/

#include <util/delay.h>																			//Стандартная библиотека временных задержек

#define CRC_EN	1																				/*Константа "Контрольная сумма протокола DCON включена"*/
#define CRC_DIS	0																				/*Константа "Контрольная сумма протокола DCON отключена"*/
#define DCON	0																				/*Константа "Протокол DCON"*/
#define MODBUS	1																				/*Константа "Протокол Modbus RTU"*/
#define COM_PORT1 0																				/*Константа для обозначения порта COM1*/
#define COM_PORT2 1																				/*Константа для обозначения порта COM2*/

#ifndef COM_RX_BUFFER_SIZE							
# warning "COM_RX_BUFFER_SIZE not defined. Value will be set by default 64 bytes"
#define COM_RX_BUFFER_SIZE 64																	/*Длина приемного буфера*/
#endif
#ifndef COM_TX_BUFFER_SIZE							
# warning "COM_TX_BUFFER_SIZE not defined. Value will be set by default 64 bytes"
#define COM_TX_BUFFER_SIZE 64																	/*Длина передающего буфера*/
#endif

static char _CHK_mode[2]={0,0};																	//Признак включения/выключения контрольной суммы в протоколе DCON
static char _Frame_pause[2];																	//Флаг превышения интервала 1.5 символа в Modbus RTU (1-интервал превышен/0-превышения не было)

static char _UART_RX_Buf[2][COM_RX_BUFFER_SIZE];												//Приемный буфер UART
static int _UART_RX_point[2];																	//Текущая позиция в приемном буфере UART
static char _UART_RX_length[2];																	//Длина принятой посылки по UART
static char _UART_RX_end[2];																	//Признак окончания принятой посылки по UART

static char _UART_TX_Buf[2][COM_TX_BUFFER_SIZE];												//Передающий буфер UART
static int _UART_TX_point[2];																	//Текущая позиция в передающем буфере UART
static char _UART_TX_length[2];																	//Длинна отправляемой посылки по UART
static char _UART_TX_end[2];																	//Признак окончания передачи по UART

#ifdef COM1_PROTOCOL
#if !(COM1_PROTOCOL-MODBUS)
//------------------------------------------------------------------------------------------
//======================== Прерывание по совпадению А таймера 1 ============================
//------------------------------------------------------------------------------------------
SIGNAL(TIMER1_COMPA_vect)
{
	_Frame_pause[0]=0;																			//Обнуление флага превышения интервала 1.5 символа
	
	_UART_RX_length[COM_PORT1]=_UART_RX_point[COM_PORT1];										//Вычисление длины принятой посылки
	_UART_RX_point[COM_PORT1]=0;														        //Указатель приемного буфера на начало
	TCCR1B=0x00;																				//Остановка таймера
	_UART_RX_end[COM_PORT1]=1;																	//Установить признак окончания приема
}

//------------------------------------------------------------------------------------------
//======================== Прерывание по совпадению B таймера 1 ============================
//------------------------------------------------------------------------------------------
SIGNAL(TIMER1_COMPB_vect)
{
	_Frame_pause[COM_PORT1]=1;																	//Установить флаг превышения интервала 1.5 символа
}

//=============================== Прерывание по приему UART0 ===============================
SIGNAL(USART0_RX_vect)
{
//---------------------------------- Если протокол Modbus ----------------------------------
	if (_Frame_pause[COM_PORT1]==0)															    //Если не было превышение интервала 1.5 символа                       
	{
		_UART_RX_Buf[COM_PORT1][_UART_RX_point[COM_PORT1]]=UDR0;								//Чтение регистра приемника
		TCNT1=0;																				//Обнуление счетного регистра таймера
		TIFR|=(1<<OCF1A)|(1<<OCF1B);															//Обнуление флага прерывания по таймеру (необходимо если прерывание возникло в момент выполнения данного обработчика)
		TCCR1B=(1<<WGM12)|(1<<CS11);															//Установка режима работы таймера "Сброс при совпадении" и коэффициента деления частоты 8
		_UART_RX_point[COM_PORT1]++;						                                    //Увеличение счетчика принятых байт
		if (_UART_RX_point[COM_PORT1]>COM_RX_BUFFER_SIZE-1) _UART_RX_point[COM_PORT1]=0;		//Защита от длинной бессмысленной команды
	}
}

#else
SIGNAL(USART0_RX_vect)
{
//----------------------------------- Если протокол DCON -----------------------------------
	char temp;																					//Вспомогательная переменная
		
	_UART_RX_Buf[COM_PORT1][_UART_RX_point[COM_PORT1]]=UDR0;									//Чтение регистра приемника
	
	switch (_UART_RX_Buf[COM_PORT1][_UART_RX_point[COM_PORT1]])			                        //Если принят символ идентификации, считать что это начало посылки
	{
		case '$':
		case '%':
		case '~':
		case '@':
		case '#':
		case '^':
		case '!':
		case '?':
		case '>':
		temp=_UART_RX_Buf[COM_PORT1][_UART_RX_point[COM_PORT1]];								//Сохранить идентификационный символ во временной переменной
		_UART_RX_point[COM_PORT1]=0;															//Установить текущую позицию в приемном буфере в ноль
		_UART_RX_Buf[COM_PORT1][0]=temp;														//Перезаписать в нулевую позицию буфера принятый элемент
	}
	
	if (_UART_RX_Buf[COM_PORT1][_UART_RX_point[COM_PORT1]]==0x0D)								//Если принят байт конца посылки
	{
		_UART_RX_length[COM_PORT1]=_UART_RX_point[COM_PORT1]+1;									//Сохранение длины посылки
		_UART_RX_point[COM_PORT1]=0;															//Очистка счетчика элементов буфера
		_UART_RX_end[COM_PORT1]=1;																//Установить признак окончания приема
	}
	else
	{
		_UART_RX_point[COM_PORT1]++;															//Увеличение счетчика элементов буфера
		if (_UART_RX_point[COM_PORT1]>COM_RX_BUFFER_SIZE-1) _UART_RX_point[COM_PORT1]=0;		//Защита от длинной бессмысленной команды
	}
}
#endif

//============================= Прерывание по передаче UART0 ===============================
SIGNAL(USART0_TX_vect)
{
	if (_UART_TX_point[COM_PORT1]==_UART_TX_length[COM_PORT1])									//Если отправлена вся посылка
	{
		_UART_TX_point[COM_PORT1]=0;															//Очистка счетчика элементов буфера
		PORTG&=~(1<<PG0);																		//Переключить RS485 на прием
		_UART_TX_end[COM_PORT1]=1;																//Установить флаг завершения передачи
	}
	else
	{
		UDR0=_UART_TX_Buf[COM_PORT1][_UART_TX_point[COM_PORT1]];								//Отправка байта по UART0
		_UART_TX_point[COM_PORT1]++;															//Увеличение счетчика элементов буфера
	}
}
#endif

#ifdef COM2_PROTOCOL
#if !(COM2_PROTOCOL-MODBUS)
//------------------------------------------------------------------------------------------
//======================== Прерывание по совпадению А таймера 3 ============================
//------------------------------------------------------------------------------------------
SIGNAL(TIMER3_COMPA_vect)
{
	_Frame_pause[COM_PORT2]=0;																	//Обнуление флага превышения интервала 1.5 символа
	
	_UART_RX_length[COM_PORT2]=_UART_RX_point[COM_PORT2];									    //Вычисление длины принятой посылки
	_UART_RX_point[COM_PORT2]=0;													            //Указатель приемного буфера на начало
	TCCR3B=0x00;																				//Остановка таймера
	_UART_RX_end[COM_PORT2]=1;																	//Установить признак окончания приема
}

//------------------------------------------------------------------------------------------
//======================== Прерывание по совпадению B таймера 3 ============================
//------------------------------------------------------------------------------------------
SIGNAL(TIMER3_COMPB_vect)
{
	_Frame_pause[COM_PORT2]=1;																	//Установить флаг превышения интервала 1.5 символа
}

//=============================== Прерывание по приему UART1 ===============================
SIGNAL(USART1_RX_vect)
{
//---------------------------------- Если протокол Modbus ----------------------------------
	if (_Frame_pause[COM_PORT2]==0)															    //Если не было превышение интервала 1.5 символа
	{
		_UART_RX_Buf[COM_PORT2][_UART_RX_point[COM_PORT2]]=UDR1;								//Чтение регистра приемника
		TCNT3=0;																                //Обнуление счетного регистра таймера
		ETIFR|=(1<<OCF3A)|(1<<OCF3B);												            //Обнуление флага прерывания по таймеру (необходжимо если прерывание возникло в момент выполнения данного обработчика)			
		TCCR3B=(1<<WGM32)|(1<<CS31);															//Установка режима работы таймера "Сброс при совпадении" и коэффициента деления частоты 8
		_UART_RX_point[COM_PORT2]++;															//Увеличение счетчика принятых байт
		if (_UART_RX_point[COM_PORT2]>=COM_RX_BUFFER_SIZE-1) _UART_RX_point[COM_PORT2]=0;		//Защита от длинной бессмысленной команды
	}
}

#else
//----------------------------------- Если протокол DCON -----------------------------------
SIGNAL(USART1_RX_vect)
{
	char temp;																					//Вспомогательная переменная

	_UART_RX_Buf[COM_PORT2][_UART_RX_point[COM_PORT2]]=UDR1;									//Чтение регистра приемника

	switch (_UART_RX_Buf[COM_PORT2][_UART_RX_point[COM_PORT2]])			                        //Если принят символ идентификации, считать что это начало посылки
	{
		case '$':
		case '%':
		case '~':
		case '@':
		case '#':
		case '^':
		case '!':
		case '?':
		case '>':
		temp=_UART_RX_Buf[COM_PORT2][_UART_RX_point[COM_PORT2]];								//Сохранить идентификационный символ во временной переменной
		_UART_RX_point[COM_PORT2]=0;															//Установить текущую позицию в приемном буфере в ноль
		_UART_RX_Buf[COM_PORT2][0]=temp;														//Перезаписать в нулевую позицию буфера принятый элемент
	}
		
	if (_UART_RX_Buf[COM_PORT2][_UART_RX_point[COM_PORT2]]==0x0D)								//Если принят байт конца посылки
	{
		_UART_RX_length[COM_PORT2]=_UART_RX_point[COM_PORT2]+1;									//Сохранение длины посылки
		_UART_RX_point[COM_PORT2]=0;															//Очистка счетчика элементов буфера
		_UART_RX_end[COM_PORT2]=1;																//Установить признак окончания приема
	}
	else
	{
		_UART_RX_point[COM_PORT2]++;															//Увеличение счетчика элементов буфера
		if (_UART_RX_point[COM_PORT2]>=COM_RX_BUFFER_SIZE-1) _UART_RX_point[COM_PORT2]=0;		//Защита от длинной бессмысленной команды
	}
}
#endif

//============================= Прерывание по передаче UART1 ===============================
SIGNAL(USART1_TX_vect)
{
	if (_UART_TX_point[COM_PORT2]==_UART_TX_length[COM_PORT2])									//Если отправлена вся посылка
	{
		_UART_TX_point[COM_PORT2]=0;															//Очистка счетчика элемнтов буфера
		PORTG&=~(1<<PG1);																		//Переключить RS485 на прием
		_UART_TX_end[COM_PORT2]=1;																//Установить флаг завершения передачи
	}
	else
	{
		UDR1=_UART_TX_Buf[COM_PORT2][_UART_TX_point[COM_PORT2]];								//Отправка байта по UART0
		_UART_TX_point[COM_PORT2]++;															//Увеличение счетчика элементов буфера
	}
}
#endif

//=========================== Функция инициализации COM порта ==============================
//Функция принимает в качестве параметров:
//port - Номер COM порта
//COM_speed - Скорости связи по UART
//Функция возвращает:
//	0x00-успешное завершение работы
//	0xFF-не корректные входные параметры

char COM_Init(int port, long COM_speed)
{
	if (port>1) return 0xFF;																	//Если не верно задан номер COM порта
	if ((COM_speed<=0) || (COM_speed>1000000)) return 0xFF;										//Если не верно задана скорость
	
	float temp;
	
	temp=(float)F_CPU/COM_speed/16-0.5;															//Расчет значения регистра скорости UART
	if (temp>=0.5)																				//Если скорость допустимая для данного кварца
	{
		if (port==0)
		{
			UBRR0H=(unsigned long)temp>>8;
			UBRR0L=(unsigned long)temp & 0x000000FF;
		}
		else 
		{
			UBRR1H=(unsigned long)temp>>8;
			UBRR1L=(unsigned long)temp & 0x000000FF;
		}		
	}
	else return 0xFF;																			//иначе, выход с ошибкой

	if (COM_speed>=19200) COM_speed=19200;														//Если значение скорости 19200 бит/сек или больше, длительность тишины равна 1.75 мс.
	if (port==0)
	{	
		UCSR0B=(1<<RXCIE0)|(1<<RXEN0)|(1<<TXEN0)|(1<<TXCIE0);									//Настройка приемо-передатчика
		UCSR0C=(1<<UCSZ00)|(1<<UCSZ01);															//Формат обмена (8N1)
		DDRG|=(1<<PG0);																			//Настройка линии управления драйвером RS485
		PORTG&=~(1<<PG0);																		//Переключить UART0 на прием

		_UART_RX_point[port]=0;																	//Указатель на начало буфера
		_UART_RX_end[port]=0;																	//Сбросить признак окончания приема
		_UART_TX_end[port]=1;																	//Установить флаг завершения предачи
		
#if !(COM1_PROTOCOL-MODBUS)
		TCCR1A=0;
		OCR1A=35*(float)F_CPU/COM_speed/_TIMER_DIV+0.5;											//Расчет длительности 3.5 символов
		OCR1B=15*(float)F_CPU/COM_speed/_TIMER_DIV+0.5;											//Расчет длительности 1.5 символов
		TIMSK|=(1<<OCIE1A)|(1<<OCIE1B);															//Разрешение прерывание по совпадению А и B таймера 1		
#endif
	}
	else
	{
		UCSR1B=(1<<RXCIE1)|(1<<RXEN1)|(1<<TXEN1)|(1<<TXCIE1);									//Настройка приемо-передатчика
		UCSR1C=(1<<UCSZ10)|(1<<UCSZ11);															//Формат обмена (8N1)
		DDRG|=(1<<PG1);																			//Настройка линии управления драйвером RS485
		PORTG&=~(1<<PG1);																		//Переключить UART1 на прием

		_UART_RX_point[port]=0;																	//Указатель на начало буфера
		_UART_RX_end[port]=0;																	//Сбросить признак окончания приема
		_UART_TX_end[port]=1;																	//Установить флаг завершения предачи
		
#if !(COM2_PROTOCOL-MODBUS)
		TCCR3A=0;
		OCR3A=35*(float)F_CPU/COM_speed/_TIMER_DIV+0.5;											//Расчет длительности 3.5 символов
		OCR3B=15*(float)F_CPU/COM_speed/_TIMER_DIV+0.5;											//Расчет длительности 1.5 символов
		ETIMSK|=(1<<OCIE3A)|(1<<OCIE3B);														//Разрешение прерывание по совпадению А и B таймера 3
#endif
	}
	sei();																						//Разрешить все прерывания			
	return 0;																					//Успешное завершение функции
}

//============ Функция включения/выключения контрольной суммы протокола DCON ===============
//Функция принимает в качестве параметров:
//port - Номер COM порта
//CHK - Признак включения/выключения контрольной суммы протокола DCON
//Функция возвращает:
//	0x00-успешное завершение работы
//	0xFF-не корректный номер COM порта

char CHK_Control(int port, char CHK)
{
	if (port>1) return 0xFF;																	//Если не верно задан номер COM порта
	_CHK_mode[port]=CHK;																		//Выбор режима контрольной суммы протокола DCON
	return 0;																					//Успешное завершение функции
}

//==================== Функция запуска передачи информации по UART =========================
//Функция принимает в качестве параметров:
//port - Номер COM порта
//Len - Длина передаваемых данных

void _UART_Go(char port, int Len)
{
	if (port==0)																				//Если указан COM1
	{
		_UART_TX_end[0]=0;																		//Сброс флага окончания передачи (отправка новой посылки)
		PORTG|=(1<<PG0);																		//Переключить RS485 на передачу
		_delay_us(5);																			//Задержка для переключения микросхемы драйвера
		_UART_TX_length[0]=Len;																	//Длина передаваемых данных
		_UART_TX_point[0]=1;																	//Позиция в передающем буфере
		UDR0=_UART_TX_Buf[0][0];																//Отправка по UART0 первого символа (остальные будут отправляться в прерывании)
	}
	else																						//Если указан COM2
	{
		_UART_TX_end[1]=0;																		//Сброс флага окончания передачи (отправка новой посылки)
		PORTG|=(1<<PG1);																		//Переключить RS485 на передачу
		_delay_us(5);																			//Задержка для переключения микросхемы драйвера
		_UART_TX_length[1]=Len;																	//Длина передаваемых данных
		_UART_TX_point[1]=1;																	//Позиция в передающем буфере
		UDR1=_UART_TX_Buf[1][0];																//Отправка по UART1 первого символа (остальные будут отправляться в прерывании)		
	}
}

//======================= Функция записи данных по протоколу DCON ==========================
//Функция принимает:
//port - Номер COM порта
//*buf - Указатель на строку передаваемых данных
//Функция возвращает:
//	0x00-успешное завершение работы
//	0xFF-не корректный номер COM порта

char Write_DCON(int port, char *buf)
{
	if (port>1) return 0xFF;																	//Если не верно задан номер COM порта
	char CHK_sum=0;																				//Переменная для расчета контрольной суммы
	char temp;																					//Вспомогательная переменная
	int Lengtch;																				//Длина команды
	
	while (_UART_TX_end[port]==0) _delay_us(5);													//Ожидание окончания предыдущей передачи
	
	Lengtch=0;																					//Обнуление счетчика символов в строке команды
	while (Lengtch<COM_TX_BUFFER_SIZE)															//Цикл, пока не встретися конец строки, символ возврата каретки или не заполнится буфер
	{
		_UART_TX_Buf[port][Lengtch]=*buf;
		if ((_UART_TX_Buf[port][Lengtch]==0) || (_UART_TX_Buf[port][Lengtch]==0x0D)) break;		//Если достигнут конец строки или встретился символ возврат каретки
		CHK_sum+=_UART_TX_Buf[port][Lengtch];
		Lengtch++;																				//Увеличить счетчик длинны строки команды
		buf++;																					//Переход на следующий символ строки команды
	}
	
	if (_CHK_mode[port]==CRC_EN)																//Если включена контрольная сумма и текущий протокол DCON
	{
		temp=CHK_sum>>4;																		//Старший символ контрольной суммы
		if (temp<=9) _UART_TX_Buf[port][Lengtch]=temp+0x30;										//Если символ цифра (0-9)
		else _UART_TX_Buf[port][Lengtch]=temp+0x37;												//Если символ буква (A-F)
		Lengtch++;
		
		temp=CHK_sum & 0x0F;																	//Младший символ контрольной суммы
		if (temp<=9) _UART_TX_Buf[port][Lengtch]=temp+0x30;										//Если символ цифра (0-9)
		else _UART_TX_Buf[port][Lengtch]=temp+0x37;												//Если символ буква (A-F)
		Lengtch++;
	}

	_UART_TX_Buf[port][Lengtch++]=0x0D;															//Замена символа конца строки на возврат каретки
	
	_UART_Go(port,Lengtch);																		//Запуск передачи данных по UART
	return 0;																					//Успешное завершение функции
}

//======================= Функция чтения данных по протоколу DCON ==========================
//Функция производит чтение содержимого приемного буфера UART
//Функция принимает:
//port - Номер COM порта
//*buf-указатель на массив в который будут помещены считанные данные
//Функция возвращает:
//	0x00-если приемный буфер UART пуст;
//	0x01-данные из приемного буфера перемещены в глобальный массив для чтения;
//	0x80-не совпадение контрольной суммы принятых данных.
//  0xFF-не корректный номер COM порта
//Функция заносит считанные данные в массив, адрес которого указан в качестве входного параметра.
//Нулевой элемент выходного массива содержит количество прочитаных байт.

char Read_DCON(int port, char *buf)
{
	int temp;																					//Вспомогательная переменная
	char CHK_sum=0;																				//Переменная для расчета контрольной суммы
	
	if (port>1) return 0xFF;																	//Если не верно задан номер COM порта
	if (_UART_RX_end[port]==0) return 0;														//Выход если признак окончания приема не установлен
	_UART_RX_end[port]=0;																		//Сброс флага окончания приема
	
	if (_CHK_mode[port]==CRC_EN)																//Если включена контрольная сумма и текущий протокол DCON
	{
		for (temp=0;temp<_UART_RX_length[port]-3;temp++) CHK_sum+=_UART_RX_Buf[port][temp];		//Обычное сумирование всех элементов буфера, за исключением CR и самой контрольной суммы
		temp=CHK_sum>>4;																		//Старший символ контрольной суммы
		if (temp<=9) temp+=0x30;																//Если символ цифра (0-9)
		else temp+=0x37;																		//Если символ буква (A-F)
		if (temp!=_UART_RX_Buf[port][_UART_RX_length[port]-3]) return 0x80;						//Выход если не совпал первый символ контрольной суммы
		
		temp=CHK_sum & 0x0F;																	//Младший символ контрольной суммы
		if (temp<=9) temp+=0x30;																//Если символ цифра (0-9)
		else temp+=0x37;																		//Если символ буква (A-F)
		if (temp!=_UART_RX_Buf[port][_UART_RX_length[port]-2]) return 0x80;						//Выход если не совпал второй символ контрольной суммы
	}
	
	*buf=_UART_RX_length[port];																	//Сохранение длинны принятых данных
	for (temp=0; temp<_UART_RX_length[port]; temp++)											//Перекопирование буфера
	{
		buf++;
		*buf=_UART_RX_Buf[port][temp];
	}
	
	return 1;																					//Данные прочитаны
}

//================= Функция расчета контрольной суммы в протоколе Modbus RTU ===============
//Функция принимает:
//*buf-указатель на массив в котором содержатся данные для расчета контрольной суммы
//Len-количество байт участвующих в расчете контрольной суммы
int _CRC_calc(char *buf, char Len)
{
	unsigned int CRC;																			//Переменная для расчета контрольной суммы
	char temp,temp2;																			//Вспомогательные переменные
	
	CRC=0xFFFF;																					//Начальное значение CRC (по алгоритму расчета CRC)
	for (temp=0; temp<Len; temp++)																//Цикл для всех байт участвующих в расчете
	{
		CRC=CRC^*buf;																			//"Исключающее или" (по алгоритму расчета CRC)
		buf++;																					//Указатель на следующий байт
		for (temp2=0; temp2<8; temp2++)															//Цикл для каждого бита в байте
		if ((CRC & 0x0001)==0) CRC=CRC>>1;														//Если младший бит в единице, просто сдвиг (по алгоритму расчета CRC)
		else
		{
			CRC=CRC>>1;																			//Сдвиг	и "Исключающее или" (по алгоритму расчета CRC)
			CRC=CRC^0xA001;																		//Полином для "Исключающего или" 1010 0000 0000 0001
		}
	}
	
	return CRC;																					//Возврат расчитанной контрольной суммы
}

//================ Функция чтения принятой посылки в протоколе Modbus RTU ==================
//Функция принимает:
//port - Номер COM порта
//*buf-массив для принятых данных
//Функция возвращает:
//	0x00-если приемный буфер UART пуст;
//	0x01-данные из приемного буфера UART перемещены в буфер для чтения;
//	0x80-не совпадение контрольной суммы принятых данных;
//	0xFF-не корректный номер COM порта
//Функция заносит считанные данные в массив, адрес которого указан в качестве входного параметра.
//Два байта контрольной суммы включены в данный массив.
//Нулевой элемент выходного массива содержит количество прочитаных байт, считая байты контрольной суммы.

char Read_Modbus(int port, char *buf)
{
	unsigned int CRC;																			//Переменная для контрольной суммы
	int temp;
	
	if (port>1) return 0xFF;																	//Выход если номер COM порта указан не верно
	if (_UART_RX_end[port]==0) return 0;														//Выход если признак окончания приема не установлен
	
	_UART_RX_end[port]=0;																		//Сброс флага окончания приема
	
	CRC=_CRC_calc(_UART_RX_Buf[port],_UART_RX_length[port]-2);									//Расчет CRC

	//Проверка контрольной суммы
	if (((CRC>>8)!=_UART_RX_Buf[port][_UART_RX_length[port]-1]) || ((CRC & 0xFF)!=_UART_RX_Buf[port][_UART_RX_length[port]-2])) return 0x80;

	*buf=_UART_RX_length[port];																	//Записать в буфер длину принятой посылки
	for (temp=0; temp<_UART_RX_length[port]; temp++)											//Перекопировать буфер
	{
		buf++;
		*buf=_UART_RX_Buf[port][temp];
	}
	return 1;																					//Данные прочитаны
}

//=============== Функция отправки ответа на команду в протоколе Modbus RTU ================
//Функция принимает:
//Addres-Адрес устройства
//Func-Код функции
//SubFunc-Код подфункции (адрес регистра)
//Data-Передаваемые данные
//Amount-Количество передаваемых элементов (регистров или ячеек)
//Функция возвращает:
//	0x00-успешное завершение работы
//	0xFE-не поддерживаемый номер функции
//	0xFF-не корректный номер COM порта

char Write_Response_Modbus(int port, char Addres, char Func, unsigned int SubFunc, char *Data, unsigned int Amount)
{
	unsigned int CRC;																			//Переменная для контрольной суммы
	int Lengtch;																				//Длинна команды
	char temp;																					//Вспомогательная переменная
	char _Error=0;																				//Флаг ошибки превышения длинны буфера
	
	if (port>1) return 0xFF;																	//Выход если номер COM порта указан не верно
	while (_UART_TX_end==0) _delay_us(5);														//Ожидание окончания предыдущей передачи
	
	Lengtch=0;
	_UART_TX_Buf[port][Lengtch++]=Addres;														//Адреса устройства
	_UART_TX_Buf[port][Lengtch++]=Func;															//Код функции
	
	if ((Func & 0x80)==0)																		//Если код функции не содержит ошибки
	{
		switch(Func)
		{
		case 0x01:
		case 0x02:
			Amount=((Amount-1)>>3)+1;															//Количество байт в посылке
			if (Amount>(COM_TX_BUFFER_SIZE-5)/2) {_Error=1; break;}
			_UART_TX_Buf[port][Lengtch++]=Amount;
			for (temp=0; temp<Amount; temp++)
			{
				_UART_TX_Buf[port][Lengtch++]=*Data;											//Перенести байт данных
				Data++;																			//Переход на следующий байт
			}
			break;

		case 0x03:
		case 0x04:
			if (Amount>(COM_TX_BUFFER_SIZE-5)/2) {_Error=1; break;}
			Amount<<=1;																			//Количество байт в посылке
			_UART_TX_Buf[port][Lengtch++]=Amount;
			for (temp=0; temp<Amount; temp++)
			{
				_UART_TX_Buf[port][Lengtch++]=*Data;											//Перенести байт данных
				Data++;																			//Переход на следующий байт
			}
			break;
			
		case 0x05:
		case 0x06:
			_UART_TX_Buf[port][Lengtch++]=SubFunc>>8;											//Старший байт кода подфункции
			_UART_TX_Buf[port][Lengtch++]=SubFunc & 0xFF;										//Младший байт кода подфункции
			
			_UART_TX_Buf[port][Lengtch++]=*Data;												//Старший байт значения регистра
			Data++;
			_UART_TX_Buf[port][Lengtch++]=*Data;												//Младший байт значения регистра
			break;
			
		case 0x0F:
		case 0x10:
			_UART_TX_Buf[port][Lengtch++]=SubFunc>>8;											//Старший байт кода подфункции
			_UART_TX_Buf[port][Lengtch++]=SubFunc & 0xFF;										//Младший байт кода подфункции
			
			_UART_TX_Buf[port][Lengtch++]=Amount>>8;											//Старший байт счетчика ячеек
			_UART_TX_Buf[port][Lengtch++]=Amount &0xFF;											//Младший байт счетчика регистра
			break;
			
			default: return 0xFE;																//Досрочный выход, если данная функция не поддерживается
		}
	}
	else _UART_TX_Buf[port][Lengtch++]=*Data;													//Если код функции содержит ошибку, добавить код ошибки
	
	if (_Error==0)
	{
		CRC=_CRC_calc(_UART_TX_Buf[port],Lengtch);												//Расчет контрольной суммы
		
		_UART_TX_Buf[port][Lengtch++]=CRC & 0xFF;												//Старший байт контрольной суммы
		_UART_TX_Buf[port][Lengtch++]=CRC>>8;													//Младший байт контрольной суммы
		
		_UART_Go(port,Lengtch);																	//Запуск передачи данных по UART
		return 0;																				//Успешное завершение функции
	}
	else return 1;
}

//==================== Функция отправки команды в протоколе Modbus RTU =====================
//Функция принимает:
//port-Номер COM порта
//Addres-Адрес устройства
//Func-Код функции
//SubFunc-Код подфункции (адрес регистра)
//*Data-Передаваемые данные
//Amount-Количество передаваемых элементов (регистров или ячеек)
//Функция возвращает:
//	0x00-успешное завершение работы
//	0xFE-не поддерживаемый номер функции
//	0xFF-не корректный номер COM порта

char Write_Request_Modbus(int port, char Addres, char Func, unsigned int SubFunc, char *Data, unsigned int Amount)
{
	unsigned int CRC;																			//Переменная для контрольной суммы
	int Lengtch;																				//Длинна команды
	char temp;																					//Вспомогательная переменная

	if (port>1) return 0xFF;																	//Выход если номер COM порта указан не верно	
	while (_UART_TX_end[port]==0) _delay_us(5);													//Ожидание окончания предыдущей передачи
	if (((Func<0x01) || (Func>0x06)) && (Func!=0x0F) && (Func!=0x10)) return 0xFE;				//Выход, если код функции не поддерживается
	
	Lengtch=0;
	_UART_TX_Buf[port][Lengtch++]=Addres;														//Адреса устройства
	_UART_TX_Buf[port][Lengtch++]=Func;															//Код функции
	_UART_TX_Buf[port][Lengtch++]=SubFunc>>8;													//Старший байт кода подфункции
	_UART_TX_Buf[port][Lengtch++]=SubFunc & 0xFF;												//Младший байт кода подфункции

	if ((Func==0x0F) || (Func==0x10))															//Для функций 0x0F и 0x10.
	{
		_UART_TX_Buf[port][Lengtch++]=Amount>>8;												//Количество элементов в посылке
		_UART_TX_Buf[port][Lengtch++]=Amount & 0xFF;											//Количество элементов в посылке
		
		if (Func==0x10) Amount<<=1;																//Количество байт в посылке
		else 
			if (Func==0x0F) Amount=((Amount-1)>>3)+1;
			else return 0xFE;
	
		_UART_TX_Buf[port][Lengtch++]=Amount;													//Занести в буфер количество записываемых регистров
		
		for (temp=0; temp<Amount; temp++) 
		{
			_UART_TX_Buf[port][Lengtch++]=*Data;												//Перенести байт данных
			Data++;																				//Переход на следующий байт
		}
	}
	else
	{
		_UART_TX_Buf[port][Lengtch++]=*Data;													//Старший байт значения регистра
		Data++;	
		_UART_TX_Buf[port][Lengtch++]=*Data;													//Младший байт значения регистра
	}
	
	CRC=_CRC_calc(_UART_TX_Buf[port],Lengtch);													//Расчет контрольной суммы
	
	_UART_TX_Buf[port][Lengtch++]=CRC & 0xFF;													//Старший байт контрольной суммы
	_UART_TX_Buf[port][Lengtch++]=CRC>>8;														//Младший байт контрольной суммы
	
	_UART_Go(port, Lengtch);																	//Запуск передачи данных по UART
	return 0;																					//Успешное завершение функции
}
#endif