/*
 * pid_boiler.h
 *
 * Created: 13.03.2018
 * Author: Antipin
 * Расчет параметров управления ПИД-регулятора
*/

#ifndef __pid_boiler
#define __pid_boiler

//============Функция реализации ПИД-управления===============//
void PID(uint32_t* time_on, uint8_t i)
{
	//Пин оптрона текущего контура
	uint8_t cur_steam = 0;
	switch (i)
	{
		// 1 контур
		case 0: cur_steam = PB4; break;
		// 2 контур
		case 1: cur_steam = PB5; break;
		// 3 контур
		case 2: cur_steam = PB7; break;
	}

	//Текущее время меньше времени закрытия клапана
	if (time_10_shim<*time_on)
	{
		//Открыть необходимый клапан
		PORTB |= (1<<cur_steam);
		//Закрыть клапан внутреннего контура
		PORTB &= ~(1 << PB6);
		if (vis[3] == '1')
		{
			vis[3] = '0';
			flag_O = 1;
		}
		//Внести данные об открытии контура в массив статуса контуров
		clsd_stms[i] = 0;
		clsd_stms[3] = 1;
		if (vis[i] == '0')
		{
			vis[i] = '1';
			flag_O = 1;
		}
	}
	
	//Текущее время больше времени открытия клапана
	else if (time_10_shim>*time_on && clsd_stms[i]==0)
	{
		//Флаг функции переключения насоса
		flag_P = 1;
		//Через 10 сек после закрытия насоса
		if (time_10_nas>=1000)
		{
			//Закрыть клапан
			PORTB &= ~(1<<cur_steam);
			//Внести данныен о закрытии контура в массив статуса контуров
			clsd_stms[i] = 1;
			if (vis[i] == '1')
			{
				vis[i] = '0';
				flag_O = 1;
			}
		}
	}
	
	//Если все внешние контуры закрыты
	if (clsd_stms[0]==1 && clsd_stms[1]==1 && clsd_stms[2]==1)
	{
		//Открыть внутренний (малый) контур
		PORTB |= (1<<PB6);
		if (vis[3] == '0')
		{
			vis[3] = '1';
			flag_O = 1;
		}
	}
	if (flag_P == 0)
	{
		//Если все внешние контуры закрыты
		if (clsd_stms[0]==1 && clsd_stms[1]==1 && clsd_stms[2]==1)
		{
			//Выключение насоса если все внешние контуры закрыты
			PORTD &= ~(1<<PD4);
			if (vis[4] == '1')
			{
				vis[4]='0';
				flag_O = 1;
			}
		}
		else
		{
			//Включение насоса если нет флага переключения
			PORTD |= (1<<PD4);
			if (vis[4] == '0')
			{
				vis[4]='1';
				flag_O = 1;
			}
		}
	}
}

//=====================Пересчет ПИД===========================//
void calculate_PID(void)
{
	//Текущая ошибка
	int16_t E;
	//Составляющие ПИД-управления
	int32_t P, I, D;
	//Процентное выражение ПИД-управления
	int32_t Y;
	//Время ПИД-управления
	uint32_t Ton;
	
	for (int i = 0; i<3; i++)
	{
		//Вычисление текущей ошибки (день)
		if (flag_N==0) E = (int16_t)temp_den_RAM[i]*1000 - cur_temp[i];
		//Вычисление текущей ошибки (ночь)
		else E = (int16_t)temp_noch_RAM[i]*1000 - cur_temp[i];
		
		//Вычисление пропорциональной составляющей ПИД-управления
		P = (int32_t) K_P_RAM[i]*E;
		//Вычисление интегральной составляющей ПИД-управления
		I = (int32_t) I_prev[i] + K_I_RAM[i]*E;
		//Вычисление дифференциальной составляющей ПИД-управления
		D = (int32_t) K_D_RAM[i]*(E-E_prev[i]);
		
		//Запись текущей ошибки как предыдущей для последующих вычислений
		E_prev[i] = E;
		//Запись текущего значения интегральной составляющей как предыдущей
		I_prev[i] = I;
		
		//вычисление процента ПИД-управления при условии исправности датчика и нулевом флаге ручного управления
		if (flag_R==0 && snc_err[i]<10)
		{
			//Вычисление процентного выражения ПИД-управления в формате 100%=100000
			Y = (int32_t)((P+I+D)/1000);
			//Защита от переполнения
			if (Y>100000) Y = 100000;
			//Защита от отрицательных значений
			if (Y<0) Y = 0;
			T_u[i] = (uint8_t) ((Y/100000)*100 + ((Y%100000)/10000)*10 + (Y%100000%10000)/1000);
			//Вычисление времени ПИД-управления в с*100
			Ton = (uint32_t) per_shim_RAM*Y/1000;
			
			//Вызов функции реализации ПИД-управления
			PID(&Ton, i);
		}
		
		//Установка скважности ручного режима управления в качестве процента ПИД-управления при условии неисправности датчика или ненулевом флаге ручного управления №1
		else if (flag_R==1 || snc_err[i]>=10)
		{
			Y =(int32_t) skv*1000;
			T_u[i] = (uint8_t) ((Y/100000)*100 + ((Y%100000)/10000)*10 + (Y%100000%10000)/1000);
			//Вычисление времени ПИД-управления в с*100
			Ton = per_shim_RAM*Y/1000;
			//Вызов функции реализации ПИД-управления
			PID(&Ton, i);
		}
	}
}

#endif