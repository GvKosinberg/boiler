#ifndef _TIMER2_																			//Защита от повторного включения файла
#define _TIMER2_

#ifndef F_CPU
# warning "F_CPU not defined. Frequency by default 14.7456MHz"
#define F_CPU 14745600UL																	//Стандартная константа задающая частоту микроконтроллера (необходима для корректной работы функций задержек)
#endif

#include <avr/iom128.h>																		//Стандартная библиотека ввода/вывода
#include <avr/interrupt.h>																	//Библиотека обработки прерываний

__volatile__ static char _LED_Time=0;														//Флаг управления циклическим сдвигом (0-выключен/1-включен)

__volatile__ char _Latch=0;																	//Признак включения фиксации нажатия кнопок
__volatile__ char _Key_flags;																//Флаги фиксаторы нажатия кнопок

__volatile__ static unsigned int _ShimPeriod[8]={0,0,0,0,0,0,0,0};							//Период ШИМ
__volatile__ static unsigned int _ShimPulse[8]={0,0,0,0,0,0,0,0};							//Длительность импульса ШИМ
__volatile__ static unsigned int _ShimCount[8]={0,0,0,0,0,0,0,0};							//Счетчик периода ШИМ
	
void _LED_Display_Shift(uint8_t SC, uint8_t RL);											//Предварительное описание функции

#ifdef TIMER2																				//Если констатнта объявлена

uint8_t _LED_Timer_Count=0;																	//Счетчик прерываний таймера

//==================== Обработчик прерывания по переполнению таймера 2 =====================
SIGNAL(TIMER2_COMP_vect)
{
//-------------------------- Управление флагами защелок кнопок -----------------------------
	if (_Latch)
	{
		if ((PINA & (1<<PA3))==0) _Key_flags|=0x01;											//Чтение состояния кнопок и фиксация флагов
		if ((PINA & (1<<PA2))==0) _Key_flags|=0x02;
		if ((PINA & (1<<PA1))==0) _Key_flags|=0x04;
		if ((PINA & (1<<PA0))==0) _Key_flags|=0x08;
	}
	
//------------------------------ Сдвиг строк на индикаторе ---------------------------------
	if(_LED_Time!=0)																		//Если функция сдвига активна
	{
		if(_LED_Timer_Count>=_LED_Time)														//Если прошла установленная задержка
		{
			_LED_Display_Shift(1,0);														//Сдвиг диспеля на 1 разряд влево
			_LED_Timer_Count=0;																//Сбросить счетчик
		}
		else _LED_Timer_Count++;															//Увеличить счетчик
	}

//-------------------------------- Генерация ШИМ сигнала -----------------------------------
	if (_ShimPulse[0]!=0)
	{
		_ShimCount[0]++;																	//Увеличить счетчик периода ШИМ
		if (_ShimCount[0]<_ShimPeriod[0])													//Если период не пройден
		{
			if (_ShimCount[0]>=_ShimPulse[0]) PORTB&=~(1<<PB4);								//Если превышена длительность управляющего импульса ШИМ, сбросить линию
		}
		else
		{
			_ShimCount[0]=0;																//Если период пройден обнулить счетчик периода ШИМ
			PORTB|=(1<<PB4);																//Установить высокий уровень (начало нового периода)
		}
	}
	if (_ShimPulse[1]!=0)
	{
		_ShimCount[1]++;																	//Увеличить счетчик периода ШИМ
		if (_ShimCount[1]<_ShimPeriod[1])													//Если период не пройден
		{
			if (_ShimCount[1]>=_ShimPulse[1]) PORTB&=~(1<<PB5);								//Если превышена длительность управляющего импульса ШИМ, сбросить линию
		}
		else
		{
			_ShimCount[1]=0;																//Если период пройден обнулить счетчик периода ШИМ
			PORTB|=(1<<PB5);																//Установить высокий уровень (начало нового периода)
		}
	}
	if (_ShimPulse[2]!=0)
	{
		_ShimCount[2]++;																	//Увеличить счетчик периода ШИМ
		if (_ShimCount[2]<_ShimPeriod[2])													//Если период не пройден
		{
			if (_ShimCount[2]>=_ShimPulse[2]) PORTB&=~(1<<PB6);								//Если превышена длительность управляющего импульса ШИМ, сбросить линию
		}
		else
		{
			_ShimCount[2]=0;																//Если период пройден обнулить счетчик периода ШИМ
			PORTB|=(1<<PB6);																//Установить высокий уровень (начало нового периода)
		}
	}
	if (_ShimPulse[3]!=0)
	{
		_ShimCount[3]++;																	//Увеличить счетчик периода ШИМ
		if (_ShimCount[3]<_ShimPeriod[3])													//Если период не пройден
		{
			if (_ShimCount[3]>=_ShimPulse[3]) PORTB&=~(1<<PB7);								//Если превышена длительность управляющего импульса ШИМ, сбросить линию
		}
		else
		{
			_ShimCount[3]=0;																//Если период пройден обнулить счетчик периода ШИМ
			PORTB|=(1<<PB7);																//Установить высокий уровень (начало нового периода)
		}
	}
	if (_ShimPulse[4]!=0)
	{
		_ShimCount[4]++;																	//Увеличить счетчик периода ШИМ
		if (_ShimCount[4]<_ShimPeriod[4])													//Если период не пройден
		{
			if (_ShimCount[4]>=_ShimPulse[4]) PORTD&=~(1<<PD4);								//Если превышена длительность управляющего импульса ШИМ, сбросить линию
		}
		else
		{
			_ShimCount[4]=0;																//Если период пройден обнулить счетчик периода ШИМ
			PORTD|=(1<<PD4);																//Установить высокий уровень (начало нового периода)
		}
	}
	if (_ShimPulse[5]!=0)
	{
		_ShimCount[5]++;																	//Увеличить счетчик периода ШИМ
		if (_ShimCount[5]<_ShimPeriod[5])													//Если период не пройден
		{
			if (_ShimCount[5]>=_ShimPulse[5]) PORTD&=~(1<<PD5);								//Если превышена длительность управляющего импульса ШИМ, сбросить линию
		}
		else
		{
			_ShimCount[5]=0;																//Если период пройден обнулить счетчик периода ШИМ
			PORTD|=(1<<PD5);																//Установить высокий уровень (начало нового периода)
		}
	}
	if (_ShimPulse[6]!=0)
	{
		_ShimCount[6]++;																	//Увеличить счетчик периода ШИМ
		if (_ShimCount[6]<_ShimPeriod[6])													//Если период не пройден
		{
			if (_ShimCount[6]>=_ShimPulse[6]) PORTD&=~(1<<PD6);								//Если превышена длительность управляющего импульса ШИМ, сбросить линию
		}
		else
		{
			_ShimCount[6]=0;																//Если период пройден обнулить счетчик периода ШИМ
			PORTD|=(1<<PD6);																//Установить высокий уровень (начало нового периода)
		}
	}
	if (_ShimPulse[7]!=0)
	{
		_ShimCount[7]++;																	//Увеличить счетчик периода ШИМ
		if (_ShimCount[7]<_ShimPeriod[7])													//Если период не пройден
		{
			if (_ShimCount[7]>=_ShimPulse[7]) PORTD&=~(1<<PD7);								//Если превышена длительность управляющего импульса ШИМ, сбросить линию
		}
		else
		{
			_ShimCount[7]=0;																//Если период пройден обнулить счетчик периода ШИМ
			PORTD|=(1<<PD7);																//Установить высокий уровень (начало нового периода)
		}
	}		
}
	
//============================== Функция запуска таймера 2 =================================
void _Timer2_Enable(void)
{
//	OCR2=36;																				//Период прерывания 10 мс (для частоты кварца 3.6864 МГц)
	OCR2=F_CPU*0.01/1024+0.5;																//Период прерывания 10 мс
	TIMSK|=(1<<OCIE2);																		//Разрешить прерывание по совпадению 2 таймера
	TCCR2=(1<<WGM21)|(1<<CS22)|(1<<CS20);													//Запуск таймера 2 в режиме "Сброс при совпадении". Коэффициент деления 1024.
	sei();																					//Разрешить все прерывания
}

#endif
#endif