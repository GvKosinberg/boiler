#ifndef _LED_																				//Защита от повторного включения файла
#define _LED_

#include <avr/iom128.h>																		//Стандартная библиотека ввода/вывода

#ifndef F_CPU
# warning "F_CPU not defined. Frequency by default 14,7456MHz"
#define F_CPU 14745600UL																	//Стандартная константа задающая частоту микроконтроллера (необходима для корректной работы функций задержек)
#endif

#define LD_OFF	0																			//Константа "Выключить светодиод"
#define LD_ON	1																			//Константа "Включить светодиод"
#define LD_SW	2																			//Константа "Переключить светодиод" (для мигания)

#define ENABLE	1																			//Константа "Включено"
#define DISABLE	0																			//Константа "Выключено"

#include <util/delay.h>																		//Стандартная библиотека временных задержек

#include "Timer2.h"																			//Библиотека работы с таймером-счетчиком 2

//Таблица кодировки
__flash const uint8_t ASCII[256]={
0x00,/*00h GCRAM 1*/0x01,/*01h GCRAM 2*/0x02,/*02h GCRAM 3*/0x03,/*03h GCRAM 4*/0x04,/*04h GCRAM 5*/0x05,/*05h GCRAM 6*/0x06,/*06h GCRAM 7*/0x07,/*07h GCRAM 8*/ 
0x08,/*08h GCRAM 1*/0x09,/*09h GCRAM 2*/0x0A,/*0Ah GCRAM 3*/0x0B,/*0Bh GCRAM 4*/0x0C,/*0Ch GCRAM 5*/0x0D,/*0Dh GCRAM 6*/0x0E,/*0Eh GCRAM 7*/0x0F,/*0Fh GCRAM 8*/ 
0x10,/*10h   */		0x11,/*11h   */		0x12,/*12h   */		0x13,/*13h   */	    0x14,/*14h   */     0x15,/*15h   */		0x16,/*16h   */	    0x17,/*17h   */
0x18,/*18h   */		0x19,/*19h   */		0x1A,/*1Ah   */		0x1B,/*1Bh   */	    0x1C,/*1Ch   */     0x1D,/*1Dh   */		0x1E,/*1Eh   */	    0x1F,/*1Fh   */
0x20,/*20h пробел */0x21,/*21h ! */		0x22,/*22h " */		0x23,/*23h # */		0x24,/*24h $ */		0x25,/*25h % */		0x26,/*26h & */		0x27,/*27h ' */
0x28,/*28h ( */		0x29,/*29h ) */		0x2A,/*2Ah * */		0x2B,/*2Bh + */		0x2C,/*2Ch , */		0x2D,/*2Dh - */		0x2E,/*2Eh . */		0x2F,/*2Fh / */
0x30,/*30h 0 */		0x31,/*31h 1 */		0x32,/*32h 2 */		0x33,/*33h 3 */		0x34,/*34h 4 */		0x35,/*35h 5 */		0x36,/*36h 6 */		0x37,/*37h 7 */
0x38,/*38h 8 */		0x39,/*39h 9 */		0x3A,/*3Ah : */		0x3B,/*3Bh ; */		0x3C,/*3Ch < */		0x3D,/*3Dh = */		0x3E,/*3Eh > */		0x3F,/*3Fh ? */
0x40,/*40h @ */		0x41,/*41h A */		0x42,/*42h B */		0x43,/*43h C */		0x44,/*44h D */		0x45,/*45h E */		0x46,/*46h F */		0x47,/*47h G */
0x48,/*48h H */		0x49,/*49h I */		0x4A,/*4Ah J */		0x4B,/*4Bh K */	    0x4C,/*4Ch L */		0x4D,/*4Dh M */		0x4E,/*4Eh N */	    0x4F,/*4Fh O */
0x50,/*50h P */		0x51,/*51h Q */		0x52,/*52h R */		0x53,/*53h S */	    0x54,/*54h T */		0x55,/*55h U */		0x56,/*56h V */	    0x57,/*57h W */
0x58,/*58h X */		0x59,/*59h Y */		0x5A,/*5Ah Z */		0x5B,/*5Bh [ */	    0x5C,/*5Ch   */		0x5D,/*5Dh ] */		0x5E,/*5Eh ^ */	    0x5F,/*5Fh _ */
0x60,/*60h ` */		0x61,/*61h a */		0x62,/*62h b */		0x63,/*63h c */	    0x64,/*64h d */		0x65,/*65h e */		0x66,/*66h f */	    0x67,/*67h g */
0x68,/*68h h */		0x69,/*69h i */		0x6A,/*6Ah j */		0x6B,/*6Bh k */	    0x6C,/*6Ch l */		0x6D,/*6Dh m */		0x6E,/*6Eh n */	    0x6F,/*6Fh o */
0x70,/*70h p */		0x71,/*71h q */		0x72,/*72h r */		0x73,/*73h s */	    0x74,/*74h t */		0x75,/*75h u */		0x76,/*76h v */	    0x77,/*77h w */
0x78,/*78h x */		0x79,/*79h y */		0x7A,/*7Ah z */		0x7B,/*7Bh   */	    0xD1,/*7Ch | */		0x7D,/*7Dh   */		0xE9,/*7Eh ~ */		0x7F,/*7Fh   */

0x80,/*80h   */		0x81,/*81h   */		0x27,/*82h , */		0x83,/*83h   */	    0x22,/*84h " */		0x85,/*85h   */		0x86,/*86h   */	    0x87,/*87h   */
0x88,/*88h   */		0x89,/*89h   */		0x8A,/*8Ah   */		0x8B,/*8Bh   */     0x8C,/*8Ch   */		0x8D,/*8Dh   */	    0x8E,/*8Eh   */		0x8F,/*8Fh   */
0x90,/*90h   */		0x60,/*91h ' */		0x61,/*92h ' */		0xCA,/*93h " */	    0xCB,/*94h " */		0xDF,/*95h . */		0x5F,/*96h _ */	    0x5F,/*97h _ */
0x98,/*98h   */		0x99,/*99h   */		0x9A,/*9Ah   */		0x9B,/*9Bh   */     0x9C,/*9Ch   */		0x9D,/*9Dh   */	    0x9E,/*9Eh   */		0x9F,/*9Fh   */
0xA0,/*A0h   */		0x8D,/*A1h   */		0xA2,/*A2h   */		0xA3,/*A3h   */	    0xA4,/*A4h   */		0xA5,/*A5h   */		0xD1,/*A6h ж */	    0xFD,/*A7h параграф */
0xA2,/*A8h Ё */		0xA9,/*A9h   */		0xAA,/*AAh   */		0xCA,/*ABh " */     0xAC,/*ACh   */		0xAD,/*ADh   */	    0xAE,/*AEh   */		0xAF,/*AFh   */
0xEF,/*B0h град. */	0xB1,/*B1h   */		0x49,/*B2h I */		0x69,/*B3h i */	    0x72,/*B4h r */		0xB5,/*B5h   */		0xB6,/*B6h   */	    0xB7,/*B7h   */
0xB5,/*B8h ё */		0xCC,/*B9h № */		0xBA,/*BAh   */		0xCB,/*BBh " */     0xBC,/*BCh   */		0xBD,/*BDh   */	    0xBE,/*BEh   */		0xBF,/*BFh   */
0x41,/*C0h А */		0xA0,/*C1h Б */		0x42,/*C2h В */		0xA1,/*C3h Г */	    0xE0,/*C4h Д */		0x45,/*C5h Е */		0xA3,/*C6h Ж */	    0xA4,/*C7h З */
0xA5,/*C8h И */		0xA6,/*C9h Й */		0x4B,/*CAh К */		0xA7,/*CBh Л */     0x4D,/*CCh М */		0x48,/*CDh Н */	    0x4F,/*CEh О */		0xA8,/*CFh П */
0x50,/*D0h Р */		0x43,/*D1h С */		0x54,/*D2h Т */		0xA9,/*D3h У */	    0xAA,/*D4h Ф */		0x58,/*D5h Х */		0xE1,/*D6h Ц */	    0xAB,/*D7h Ч */
0xAC,/*D8h Ш */		0xE2,/*D9h Щ */		0xAD,/*DAh Ъ */		0xAE,/*DBh Ы */     0xC4,/*DCh Ь */		0xAF,/*DDh Э */	    0xB0,/*DEh Ю */		0xB1,/*DFh Я */
0x61,/*E0h а */		0xB2,/*E1h б */		0xB3,/*E2h в */		0xB4,/*E3h г */	    0xE3,/*E4h д */		0x65,/*E5h е */		0xB6,/*E6h ж */	    0xB7,/*E7h з */
0xB8,/*E8h и */		0xB9,/*E9h й */		0xBA,/*EAh к */		0xBB,/*EBh л */     0xBC,/*ECh м */		0xBD,/*EDh н */	    0x6F,/*EEh о */		0xBE,/*EFh п */
0x70,/*F0h р */		0x63,/*F1h с */		0xBF,/*F2h т */		0x79,/*F3h у */	    0xE4,/*F4h ф */		0x78,/*F5h х */		0xE5,/*F6h ц */	    0xC0,/*F7h ч */
0xC1,/*F8h ш */		0xE6,/*F9h щ */		0xC2,/*FAh ъ */		0xC3,/*FBh ы */	    0xC4,/*FCh ь */		0xC5,/*FDh э */		0xC6,/*FEh ю */	    0xC7,/*FFh я */
};


//=========== Функция генерация стробирующего импульса на линии индикатора "E" =============
void _StrobE(void)
{
	PORTE|=(1<<PE6);																		//Установить линию
	_delay_us(1);																			//Задержка
	PORTE&=~(1<<PE6);																		//Сбросить линию
}

//============================== Функция настройки индикатора ==============================
void _LED_Function_Set(void)
{
#if	_LED_DATA																				//Для аналоговых модулей (где линии данных расположены на PORTA4-PORTA7)
	PORTA=0x20;																				//Первая тетрада (4 битный режим)
	_StrobE();																				//Импульс передачи данных (строб записи)
	
	PORTA=0x20;																				//Повторная передача первой тетрады (требуется чтобы индикатор перешел в 4 битный режим)
	_StrobE();																				//Импульс передачи данных
	
	PORTA=0xA0;																				//Вторая тетрада (2 строчный режим, 5*8 точек на символ, русская таблица кодировок)
	_StrobE();																				//Импульс передачи данных
#else																						//Для дискретных модулей (где линии данных расположены на PORTF0-PORTF3)
	PORTF=0x02;																				//Первая тетрада (4 битный режим)
	_StrobE();																				//Импульс передачи данных (строб записи)
	
	PORTF=0x02;																				//Повторная передача первой тетрады (требуется чтобы индикатор перешел в 4 битный режим)
	_StrobE();																				//Импульс передачи данных
	
	PORTF=0x0A;																				//Вторая тетрада (2 строчный режим, 5*8 точек на символ, русская таблица кодировок)
	_StrobE();																				//Импульс передачи данных
#endif
}

//============================ Функция управления индикатором ==============================
//Функция принимает параметры:
//Power - флаг управления состоянием индикатора (включен/выключен)
//Cursor - флаг управления курсором (включен/выключен)
//Blink - флаг управления мерцанием (НЕ СООТВЕТСВУЕТ DATASHEET!)

void _LED_Display_Control(uint8_t Power, uint8_t Cursor, uint8_t Blink)
{
#if	_LED_DATA																				//Для аналоговых модулей (где линии данных расположены на PORTA4-PORTA7)	
	uint8_t temp=0x80;																		//Вспомогательная переменная

	PORTA=0x00;																				//Старшая тетрада
	_StrobE();																				//Строб записи
	
	if (Power) temp|=0x40;
	if (Cursor) temp|=0x20;
	if (Power) temp|=0x10;
	PORTA=temp;																				//Младшая тетрада
	_StrobE();																				//Строб записи	
#else																						//Для дискретных модулей (где линии данных расположены на PORTF0-PORTF3)	
	uint8_t temp=0x08;																		//Вспомогательная переменная

	PORTF=0x00;																				//Старшая тетрада
	_StrobE();																				//Строб записи	
	
	if (Power) temp|=0x04;
	if (Cursor) temp|=0x02;
	if (Power) temp|=0x01;
	PORTF=temp;																				//Младшая тетрада
	_StrobE();																				//Строб записи		
#endif	
}

//========================== Функция установки режима индикатора ===========================
//Функция принимает параметры:
//ID - флаг управления направлением смещения указателя текущего символа в памяти (0-декремент/1-инкремент)
//S - флаг управления сдвигом дисплея (при S=1 и ID=0 сдвиг вправо/при S=1 и ID=0 сдвиг влево, при S=0 сдвига нет)

void _LED_Entry_Mode_Set(uint8_t ID, uint8_t S)
{
#if	_LED_DATA																				//Для аналоговых модулей (где линии данных расположены на PORTA4-PORTA7)		
	uint8_t temp=0x40;																		//Вспомогательная переменная
	
	PORTA=0x00;																				//Старшая тетрада																				
	_StrobE();																				//Строб записи
	
	if (ID) temp|=0x20;
	if (S) temp|=0x10;
	PORTA=temp;																				//Младшая тетрада
	_StrobE();																				//Строб записи
#else																						//Для дискретных модулей (где линии данных расположены на PORTF0-PORTF3)	
	uint8_t temp=0x04;																		//Вспомогательная переменная
	
	PORTF=0x00;																				//Старшая тетрада
	_StrobE();																				//Строб записи
	
	if (ID) temp|=0x02;
	if (S) temp|=0x01;
	PORTF=temp;																				//Младшая тетрада
	_StrobE();																				//Строб записи
#endif	
}

//=========================== Функция сдвига курсора и дисплея =============================
//Функция принимает параметры:
//SC - направление сдвига (0-влево/1-вправо)
//RL - выбор сдвигаемых объектов (0-только курсор/1-дисплей и курсор)

void _LED_Display_Shift(uint8_t SC, uint8_t RL)
{
#if	_LED_DATA																				//Для аналоговых модулей (где линии данных расположены на PORTA4-PORTA7)		
	uint8_t temp=0x00;																		//Вспомогательная переменная
	
	PORTA=0x10;																				//Старшая тетрада
	_StrobE();																				//Строб записи
	
	if (SC) temp|=0x80;
	if (RL) temp|=0x40;
	PORTA=temp;																				//Младшая тетрада
	_StrobE();																				//Строб записи
#else																						//Для дискретных модулей (где линии данных расположены на PORTF0-PORTF3)	
	uint8_t temp=0x00;																		//Вспомогательная переменная
	
	PORTF=0x01;																				//Старшая тетрада
	_StrobE();																				//Строб записи
	
	if (SC) temp|=0x08;
	if (RL) temp|=0x04;
	PORTF=temp;																				//Младшая тетрада
	_StrobE();																				//Строб записи
#endif
}

//======================= Функция установки указателя адреса в DDRAM =======================
//Функция принимает параметры:
//Addr - Адрес в DDRAM

void _LED_Set_Addres(uint8_t Addr)
{
#if	_LED_DATA																				//Для аналоговых модулей (где линии данных расположены на PORTA4-PORTA7)		
	uint8_t temp=0x80;																		//Вспомогательная переменная
	
	temp|=Addr;																				//Добавление адреса к записываемой информации
	PORTA=temp & 0xF0;																			//Старшая тетрада
	_StrobE();																				//Строб записи
	
	PORTA=temp<<4;																			//Младшая тетрада
	_StrobE();																				//Строб записи
#else																						//Для дискретных модулей (где линии данных расположены на PORTF0-PORTF3)	
	uint8_t temp=0x80;																		//Вспомогательная переменная
	
	temp|=Addr;																				//Добавление адреса к записываемой информации
	PORTF=temp>>4;																			//Старшая тетрада
	_StrobE();																				//Строб записи
	
	PORTF=temp & 0x0F;																		//Младшая тетрада
	_StrobE();																				//Строб записи
#endif
}

//================================ Функция очистки дисплея =================================
void LED_Clear(void)
{
#if	_LED_DATA																				//Для аналоговых модулей (где линии данных расположены на PORTA4-PORTA7)		
	PORTA=0x00;																				//Старшая тетрада
	_StrobE();																				//Строб записи
	PORTA=0x10;																				//Младшая тетрада
	_StrobE();																				//Строб записи
	_delay_ms(1);
#else																						//Для дискретных модулей (где линии данных расположены на PORTF0-PORTF3)	
	PORTF=0x00;																				//Старшая тетрада
	_StrobE();																				//Строб записи
	PORTF=0x01;																				//Младшая тетрада
	_StrobE();																				//Строб записи
	_delay_ms(1);
#endif
}

//=========== Функция установки курсора в начальное положение и отмены сдвигов =============
void LED_Return_Home(void)
{
#if	_LED_DATA																				//Для аналоговых модулей (где линии данных расположены на PORTA4-PORTA7)		
	PORTA=0x00;																				//Старшая тетрада
	_StrobE();																				//Строб записи
	PORTA=0x20;																				//Младшая тетрада
	_StrobE();																				//Строб записи
#else																						//Для дискретных модулей (где линии данных расположены на PORTF0-PORTF3)	
	PORTF=0x00;																				//Старшая тетрада
	_StrobE();																				//Строб записи
	PORTF=0x02;																				//Младшая тетрада
	_StrobE();																				//Строб записи
#endif
}

//========================= Функция инициализации LED индикатора ===========================
void LED_Init(void)
{
	DDRE|=(1<<PE3)|(1<<PE5)|(1<<PE6);														//Настройка линий "RS", "R/W" и "E" индикатора
	PORTE|=(1<<PE3)|(1<<PE6);																//Отключение выборки индикатора (для корректного сброса необходимо обеспечить состояние линии H,H->L)
	_delay_ms(10);																			//Задержка для сброса
	
	PORTE&=~((1<<PE3)|(1<<PE5)|(1<<PE6));													//Выборка индикатора
	
#if	_LED_DATA																				//Для аналоговых модулей (где линии данных расположены на PORTA4-PORTA7)	
	DDRA|=0xF0;																				//Настройка линий данных индикатора
#else																						//Для дискретных модулей (где линии данных расположены на PORTF0-PORTF3)
	DDRF|=0x0F;																				//Настройка линий данных индикатора
#endif	
	_delay_ms(10);																			//Задержка для стабилизации питания	
	
	_LED_Function_Set();																	//Настройка индикатора (4 битный режим, 2 строчный режим, 5*8 точек на символ, русская таблица кодировок)
	_LED_Display_Control(1,0,0);															//Управление дисплеем (включить дисплей, выключить курсор, отключить мерцание)
	LED_Clear();																			//Провести очистку дисплея
	LED_Return_Home();																		//Сброс курсора в начало 1 строки
	_LED_Entry_Mode_Set(1,0);																//Управление смещением индикатора (инкремент адреса, сдвиг отключен)
}

//=============== Функция записи кода из таблицы в текущую позицию курсора =================
void _LED_Write_Byte(uint8_t Data)
{
	PORTE|=(1<<PE3);																		//Линию "RS" на запись данных

#if	_LED_DATA																				//Для аналоговых модулей (где линии данных расположены на PORTA4-PORTA7)		
	PORTA=Data & 0xF0;																		//Старшая тетрада
	_StrobE();																				//Строб записи
	PORTA=Data<<4;																			//Младшая тетрада
	_StrobE();																				//Строб записи
#else																						//Для дискретных модулей (где линии данных расположены на PORTF0-PORTF3)
	PORTF=Data>>4;																			//Старшая тетрада
	_StrobE();																				//Строб записи
	PORTF=Data & 0x0F;																		//Младшая тетрада
	_StrobE();																				//Строб записи
#endif
	
	PORTE&=~(1<<PE3);																		//Линию "RS" на запись команд
}

//==================== Функция записи символа в текущую позицию курсора ====================
void _LED_Write_Char(uint8_t Data)
{
	PORTE|=(1<<PE3);																		//Линию "RS" на запись данных

#if	_LED_DATA																				//Для аналоговых модулей (где линии данных расположены на PORTA4-PORTA7)		
	PORTA=ASCII[Data] & 0xF0;																//Старшая тетрада
	_StrobE();																				//Строб записи
	PORTA=ASCII[Data]<<4;																	//Младшая тетрада
	_StrobE();																				//Строб записи
#else																						//Для дискретных модулей (где линии данных расположены на PORTF0-PORTF3)
	PORTF=ASCII[Data]>>4;																	//Старшая тетрада
	_StrobE();																				//Строб записи
	PORTF=ASCII[Data] & 0x0F;																//Младшая тетрада
	_StrobE();																				//Строб записи
#endif	
	
	PORTE&=~(1<<PE3);																		//Линию "RS" на запись команд
}

//==================== Функция записи строки в текущую позицию курсора =====================
void LED_Write_String(char *buf)
{
	uint8_t temp;																			//Вспомогательная переменная
	
	for(temp=0; temp<64; temp++)															//Если длина строки превышает 64 символа, отбросить лишнии символы
	{
		if(*buf==0) break;																	//Досрочный выход если достигнут конец строки
		_LED_Write_Char(*buf);																//Отправить символ на дисплей
		buf++;																				//Перейти к слудующему символу
	}
}

//== Функция записи строки в текущую позицию курсора с использованием флеш памяти =========
void LED_Write_String_P(__flash const char *buf)
{
	uint8_t temp;																			//Вспомогательная переменная
	
	for(temp=0; temp<64; temp++)															//Если длина строки превышает 64 символа, отбросить лишнии символы
	{
		if(*buf==0) break;																	//Досрочный выход если достигнут конец строки
		_LED_Write_Char(*buf);																//Отправить символ на дисплей
		buf++;																				//Перейти к слудующему символу
	}
}

//============================ Функция установки позиции курсора ===========================
void LED_SetPos(uint8_t Y, uint8_t X)
//Функция принимает параметры:
//Y - номер строки (0 или 1)
//X - позиция символа в строке (от 0 до 63)
{
	if (Y>1) return;																		//Проверка корретности аргументов
	if (X>63) return;
	
	_LED_Set_Addres((Y<<6)+X);																//Установить указатель адреса DDRAM в требуемую позицию
}

//==================== Функция включения/выключения отображения курсора ====================
void LED_CursorEnable(uint8_t EN)
//Функция принимает параметры:
//EN - признак отображения курсора (0-не отображать/1-отображать)
{
	if (EN!=0) EN=1;
	_LED_Display_Control(1,EN,0);															//Управление дисплеем (включить дисплей, управление курсором, отключить мерцание)
}

#ifdef TIMER2																				//Если таймер 2 подключен
//==================== Функция запуска циклического сдвига сообщений =======================
void LED_Cycle_Shift(char time)
//Функция принимает параметры:
//status - Временная задержка между сдвигами на 1 символ (1 единица соответсвует 50 мс. При значении 0, сдвиг не осуществляется)
{
#ifdef TIMER2
	_LED_Time=time;
	_Timer2_Enable();																		//Настроить и запустить таймер 2
#endif
}
#endif

//============================ Функция управления светодиодом ==============================
//Функция принимает в качестве параметров:
//Enable - параметр управляющий состоянием светодиода (1-включен, 0-выключен).

void Led(char power)
{
	DDRG|=0x10;																	//Настройка линии управления светодиодом
	switch(power)
	{
	case 0:	PORTG&=0xEF; break;													//Выключить светодиод
	case 1: PORTG|=0x10; break;													//Включить светодиод
	case 2: PORTG^=0x10;														//Переключить светодиод
	}
}
#endif